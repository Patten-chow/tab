<!doctype html>
<html lang="zh-HK">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Guitar Tab — iPad Prototype</title>
  <style>
    :root{--measure-w:260px;--measure-h:120px;--gap:12px}
    body{font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin:12px; background:#f7f7f8}
    header{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    button{padding:8px 12px;border-radius:8px;border:1px solid #ddd;background:white}
    .toolbar{display:flex;gap:8px;flex-wrap:wrap}
    #sheet{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;gap:var(--gap)}
    .measure{width:var(--measure-w);height:var(--measure-h);background:white;border-radius:8px;box-shadow:0 1px 0 rgba(0,0,0,0.06);overflow:hidden;display:flex;flex-direction:column}
    .measure .label{font-size:12px;padding:6px 8px;border-bottom:1px dashed #eee;background:#fafafa}
    canvas{touch-action:none;display:block}
    .controls{display:flex;gap:6px;align-items:center}
    .hint{font-size:13px;color:#666;margin-left:8px}
    input[type=number]{width:56px}
    @media (max-width:820px){:root{--measure-w:170px;--measure-h:100px}}
  </style>
</head>
<body>
  <header>
    <div class="toolbar">
      <button id="addMeasure">Add Measure</button>
      <button id="clearAll">Clear All</button>
      <button id="exportPNG">Export PNG</button>
      <label style="display:inline-flex;align-items:center;gap:6px"><input id="drawMode" type="checkbox" checked> Draw</label>
      <label style="display:inline-flex;align-items:center;gap:6px">Pen size <input id="penSize" type="number" min="1" max="16" value="3"></label>
      <span class="hint">每行 4 個小節（會自動換行） • 用 Apple Pencil 或 手指寫/畫</span>
    </div>
  </header>

  <main>
    <div id="sheet"></div>
  </main>

  <script>
    // Prototype: measures are canvases for freehand writing (Apple Pencil friendly)
    const MEASURES_PER_ROW = 4;
    const sheet = document.getElementById('sheet');
    const addBtn = document.getElementById('addMeasure');
    const clearAllBtn = document.getElementById('clearAll');
    const exportBtn = document.getElementById('exportPNG');
    const drawMode = document.getElementById('drawMode');
    const penSizeInput = document.getElementById('penSize');

    // store canvases
    let measures = [];

    function createMeasure(index){
      const wrap = document.createElement('div');
      wrap.className = 'measure';

      const label = document.createElement('div'); label.className='label';
      label.textContent = `Measure ${index+1}`;
      wrap.appendChild(label);

      const cvs = document.createElement('canvas');
      cvs.width = Math.round(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-w')) * devicePixelRatio);
      cvs.height = Math.round(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-h')) * devicePixelRatio) - 28 * devicePixelRatio;
      cvs.style.width = '100%';
      cvs.style.height = `calc(var(--measure-h) - 28px)`;
      cvs.dataset.index = index;

      wrap.appendChild(cvs);

      // draw tab staff lines as background
      const ctx = cvs.getContext('2d');
      ctx.scale(devicePixelRatio, devicePixelRatio);
      const wCSS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-w'));
      const hCSS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-h')) - 28;
      ctx.clearRect(0,0,wCSS,hCSS);
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#e2e2e2';
      // 6 strings
      const margin = 12; const gap = (hCSS - margin*2) / 5;
      for(let i=0;i<6;i++){
        const y = margin + i*gap;
        ctx.beginPath(); ctx.moveTo(6,y); ctx.lineTo(wCSS-6,y); ctx.stroke();
      }

      // set up drawing state
      let drawing=false;
      let last = null;

      function getPoint(e){
        const rect = cvs.getBoundingClientRect();
        const x = (e.clientX ?? e.touches?.[0]?.clientX) - rect.left;
        const y = (e.clientY ?? e.touches?.[0]?.clientY) - rect.top;
        return {x,y};
      }

      function pointerDown(e){
        if(!drawMode.checked) return;
        e.preventDefault(); drawing=true; last = getPoint(e);
      }
      function pointerMove(e){
        if(!drawing) return;
        e.preventDefault(); const p = getPoint(e);
        const ctx2 = cvs.getContext('2d');
        ctx2.lineCap = 'round';
        ctx2.lineJoin = 'round';
        ctx2.strokeStyle = '#111';
        ctx2.lineWidth = Number(penSizeInput.value);
        ctx2.beginPath(); ctx2.moveTo(last.x, last.y); ctx2.lineTo(p.x,p.y); ctx2.stroke(); last = p;
      }
      function pointerUp(e){ if(!drawing) return; drawing=false; last=null; }

      // pointer events for stylus + touch
      cvs.addEventListener('pointerdown', pointerDown);
      cvs.addEventListener('pointermove', pointerMove);
      window.addEventListener('pointerup', pointerUp);

      // also support touch for some browsers
      cvs.addEventListener('touchstart', (e)=>{ pointerDown(e); }, {passive:false});
      cvs.addEventListener('touchmove', (e)=>{ pointerMove(e); }, {passive:false});
      cvs.addEventListener('touchend', (e)=>{ pointerUp(e); }, {passive:false});

      return {wrap, cvs, clear: ()=>{
        const ctx3 = cvs.getContext('2d');
        ctx3.setTransform(1,0,0,1,0,0);
        ctx3.clearRect(0,0,cvs.width,cvs.height);
        // redraw staff lines
        ctx3.scale(devicePixelRatio, devicePixelRatio);
        ctx3.lineWidth = 1;
        ctx3.strokeStyle = '#e2e2e2';
        const wCSS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-w'));
        const hCSS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-h')) - 28;
        const margin = 12; const gap = (hCSS - margin*2) / 5;
        for(let i=0;i<6;i++){ const y = margin + i*gap; ctx3.beginPath(); ctx3.moveTo(6,y); ctx3.lineTo(wCSS-6,y); ctx3.stroke(); }
      }};
    }

    function refreshLayout(){
      // clear sheet, rebuild rows of 4
      sheet.innerHTML = '';
      for(let i=0;i<measures.length;i+=MEASURES_PER_ROW){
        const rowWrap = document.createElement('div'); rowWrap.className='row';
        for(let j=0;j<MEASURES_PER_ROW;j++){
          const idx = i+j;
          if(idx < measures.length) rowWrap.appendChild(measures[idx].wrap);
          else{
            // placeholder to keep layout tidy
            const ph = document.createElement('div'); ph.style.width=getComputedStyle(document.documentElement).getPropertyValue('--measure-w'); ph.style.height=getComputedStyle(document.documentElement).getPropertyValue('--measure-h'); rowWrap.appendChild(ph);
          }
        }
        sheet.appendChild(rowWrap);
      }
    }

    function addMeasure(){
      const m = createMeasure(measures.length);
      measures.push(m);
      refreshLayout();
    }

    addBtn.addEventListener('click', addMeasure);
    clearAllBtn.addEventListener('click', ()=>{ if(!confirm('Clear all measures?')) return; measures.forEach(m=>m.clear()); measures = []; refreshLayout(); });

    // export: compose all measure canvases into one tall canvas and download
    exportBtn.addEventListener('click', async ()=>{
      if(measures.length===0){ alert('No measures. Add some first.'); return; }
      // compute rows
      const rows = Math.ceil(measures.length / MEASURES_PER_ROW);
      // get CSS dims
      const wCSS = (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-w')) * MEASURES_PER_ROW) + (parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) * (MEASURES_PER_ROW -1));
      const hCSS = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-h')) * rows + 20;
      const outW = Math.round(wCSS * devicePixelRatio);
      const outH = Math.round(hCSS * devicePixelRatio);
      const out = document.createElement('canvas'); out.width=outW; out.height=outH;
      const ctx = out.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,outW,outH);

      // draw measure canvases into grid
      const measureW = Math.round(parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-w')) * devicePixelRatio);
      const measureH = Math.round((parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--measure-h')) - 0) * devicePixelRatio);

      for(let i=0;i<measures.length;i++){
        const row = Math.floor(i / MEASURES_PER_ROW);
        const col = i % MEASURES_PER_ROW;
        const src = measures[i].cvs;
        // draw label above measure
        const dx = Math.round(col * (measureW + parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) * devicePixelRatio));
        const dy = Math.round(row * (measureH + parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--gap')) * devicePixelRatio));
        // label background
        ctx.fillStyle='#fafafa'; ctx.fillRect(dx,dy,measureW,28*devicePixelRatio);
        ctx.fillStyle='#111'; ctx.font = `${14*devicePixelRatio}px sans-serif`;
        ctx.fillText(`Measure ${i+1}`, dx+8*devicePixelRatio, dy + 18*devicePixelRatio);
        ctx.drawImage(src, dx, dy + 28*devicePixelRatio, measureW, measureH - 28*devicePixelRatio);
      }

      // download
      const url = out.toDataURL('image/png');
      const a = document.createElement('a'); a.href=url; a.download = 'guitar_tab.png'; a.click();
    });

    // initial measures
    for(let i=0;i<4;i++) addMeasure();
  </script>
</body>
</html>
